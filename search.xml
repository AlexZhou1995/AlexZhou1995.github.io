<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CapsuleNetwork调研</title>
      <link href="/2021/09/10/CapsuleNetwork/"/>
      <url>/2021/09/10/CapsuleNetwork/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么提出capsule">为什么提出capsule</h2><p>在讨论胶囊网络前，我们先来看一下目前最通用的深度学习模型之一，卷积神经网络（CNN）。 CNN目前已经完成了很多不可思议的任务，对于整个机器学习领域都产生了很大的影响。然而，CNN善于检测特征，却在探索特征（视角，大小，方位）之间的空间关系方面效果较差。举一个简单的例子，对于一张人脸而言，它的组成部分包括面部轮廓，两个眼睛，一个鼻子和一张嘴巴。对于CNN而言，这些部分就足以识别一张人脸；然而，这些组成部分的相对位置以及朝向就没有那么重要。 <img src="16086894305226.jpg" /></p><p>一个简单的CNN模型可以正确提取鼻子、眼睛和嘴巴的特征，但会错误地激活神经元进行人脸检测。如果不了解空间方向，大小不匹配，那么对于人脸检测的激活将会太高，比如下图95%。</p><p><img src="16086894931180.jpg" /></p><p>现在，假设每个神经元都包含特征的可能性和属性。例如，神经元输出的是一个包含 [可能性，方向，大小] 的向量。利用这种空间信息，就可以检测鼻子、眼睛和耳朵特征之间的方向和大小的一致性，因此对于人脸检测的激活输出就会低很多。</p><p><img src="16086895133550.jpg" /></p><p>而如果我们将神经元从标量升级为向量，则相同的胶囊就可以检测不同方向的同一个物体类别</p><p><img src="16086896627419.jpg" /></p><h2 id="capsule的结构">Capsule的结构</h2><p>基本一张图搞定，很好理解。这张图下游只有一个向量，实际上可以有多个向量，然后通过动态路由来决定每一个c的值。</p><p><img src="16086902514866.jpg" /></p><p><img src="16086901663237.jpg" /></p><p>唯一需要想明白的是，为什么要这样做squash</p><h2 id="动态路由">动态路由</h2><p>动态路由确定的是上图的标量c，动态路由的motivation：低层的胶囊将会输入到和它“一致”的胶囊中。 &gt; Lower level capsule will send its input to the higher level capsule that “agrees” with its input. This is the essence of the dynamic routing algorithm.</p><p>动态路由算法如下所示： <img src="16086904139573.jpg" /></p><p>也十分的好理解，刚开始将分配权重b设置为0，将l层的向量平均分发给l+1层，计算得出l+1层的结果后，反向计算l层向量到l+1层向量的距离，以此修改分配权重b。把l+1看做是聚类中心就更好理解了。</p><h2 id="mind">MIND</h2><p>MIND在capsule的基础之上，对其进行了一些改进。</p><blockquote><p>胶囊是一种新的神经元，它由传统的神经网络用一个向量来表示，而不是用一个标量来表示。基于向量的胶囊预计能够代表一个实体的不同性质，其中胶囊的方向代表一个属性，胶囊的长度用来表示该属性存在的概率。相应地，多兴趣提取器层的目标是学习表示用户兴趣属性的表示以及是否存在相应的兴趣。胶囊与兴趣表征之间的语义联系促使我们将行为/兴趣表征视为行为/兴趣胶囊，并采用动态路径从行为胶囊中学习兴趣胶囊。然而，原有的图像数据路由算法并不能直接应用于用户行为数据的处理。因此，我们提出了行为兴趣（B2I）动态路由算法，将用户的行为自适应地聚合到兴趣表示向量中，与原有的路由算法在三个方面有所不同：Shared bilinear mapping matrix、Randomly initialized routing logits、Dynamic interest number.</p></blockquote><h3 id="shared-bilinear-mapping-matrix">Shared bilinear mapping matrix</h3><p>其实也是fixed bilinear mapping matrix，也就是上面结构图中的<span class="math inline">\(W\)</span>，对于不同的capsule，只用同一个映射变量<span class="math inline">\(W\)</span>。作者的理由： 1. 用户序列是变长的，因此不好设置某个数量的<span class="math inline">\(W\)</span> 2. 希望item embedding映射到同一个空间</p><p>感觉有道理。</p><h3 id="randomly-initialized-routing-logits">Randomly initialized routing logits</h3><p>顾名思义，高斯分布随机初始化的c，代替原本全0的c</p><h3 id="dynamic-interest-number">Dynamic interest number</h3><p>对于每个用户，兴趣的个数是动态确定的： <span class="math display">\[K_{u}^{\prime}=\max \left(1, \min \left(K, \log _{2}\left(\left|\mathcal{I}_{u}\right|\right)\right)\right)\]</span> 这条感觉是凑数的</p><h2 id="代码">代码</h2><p>可以看 https://github.com/bojone/Capsule 或者这里也有另一个实现： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.initializers <span class="keyword">import</span> RandomNormal</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.layers <span class="keyword">import</span> Layer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CapsuleLayer</span><span class="params">(Layer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, input_units, out_units, max_len, k_max, iteration_times=<span class="number">3</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                 init_std=<span class="number">1.0</span>, **kwargs)</span>:</span></span><br><span class="line">        self.input_units = input_units</span><br><span class="line">        self.out_units = out_units</span><br><span class="line">        self.max_len = max_len</span><br><span class="line">        self.k_max = k_max</span><br><span class="line">        self.iteration_times = iteration_times</span><br><span class="line">        self.init_std = init_std</span><br><span class="line">        super(CapsuleLayer, self).__init__(**kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span><span class="params">(self, input_shape)</span>:</span></span><br><span class="line">        <span class="comment"># self.routing_logits = self.add_weight(shape=[1, self.k_max, self.max_len],</span></span><br><span class="line">        <span class="comment">#                                       initializer=RandomNormal(stddev=self.init_std),</span></span><br><span class="line">        <span class="comment">#                                       trainable=False, name="B", dtype=tf.float32)</span></span><br><span class="line">        self.bilinear_mapping_matrix = self.add_weight(shape=[self.input_units, self.out_units],</span><br><span class="line">                                                       initializer=RandomNormal(stddev=self.init_std),</span><br><span class="line">                                                       name=<span class="string">"S"</span>, dtype=tf.float32)</span><br><span class="line">        super(CapsuleLayer, self).build(input_shape)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inputs, **kwargs)</span>:</span></span><br><span class="line">        behavior_embddings, seq_len = inputs</span><br><span class="line">        batch_size = tf.shape(behavior_embddings)[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#seq_len = tf.squeeze(seq_len)</span></span><br><span class="line">        seq_len_tile = tf.tile(seq_len, [<span class="number">1</span>, self.k_max])</span><br><span class="line"></span><br><span class="line">        routing_logits = tf.stop_gradient(tf.truncated_normal(shape=[<span class="number">1</span>, self.k_max, self.max_len], stddev=self.init_std, name=<span class="string">'B'</span>))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.iteration_times):</span><br><span class="line">            mask = tf.sequence_mask(seq_len_tile, self.max_len)</span><br><span class="line">            pad = tf.ones_like(mask, dtype=tf.float32) * (<span class="number">-2</span> ** <span class="number">32</span> + <span class="number">1</span>)</span><br><span class="line">            routing_logits_with_padding = tf.where(mask, tf.tile(routing_logits, [batch_size, <span class="number">1</span>, <span class="number">1</span>]), pad)</span><br><span class="line">            weight = tf.nn.softmax(routing_logits_with_padding)</span><br><span class="line">            behavior_embdding_mapping = tf.tensordot(behavior_embddings, self.bilinear_mapping_matrix, axes=<span class="number">1</span>)</span><br><span class="line">            Z = tf.matmul(weight, behavior_embdding_mapping)</span><br><span class="line">            interest_capsules = squash(Z)</span><br><span class="line">            delta_routing_logits = tf.reduce_sum(</span><br><span class="line">                tf.matmul(interest_capsules, tf.transpose(behavior_embdding_mapping, perm=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>])),</span><br><span class="line">                axis=<span class="number">0</span>, keep_dims=<span class="literal">True</span></span><br><span class="line">            )</span><br><span class="line">            routing_logits += delta_routing_logits</span><br><span class="line">        interest_capsules = tf.reshape(interest_capsules, [<span class="number">-1</span>, self.k_max, self.out_units])</span><br><span class="line">        <span class="keyword">return</span> interest_capsules</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_output_shape</span><span class="params">(self, input_shape)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">None</span>, self.k_max, self.out_units)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_config</span><span class="params">(self, )</span>:</span></span><br><span class="line">        config = &#123;<span class="string">'input_units'</span>: self.input_units, <span class="string">'out_units'</span>: self.out_units, <span class="string">'max_len'</span>: self.max_len,</span><br><span class="line">                  <span class="string">'k_max'</span>: self.k_max, <span class="string">'iteration_times'</span>: self.iteration_times, <span class="string">"init_std"</span>: self.init_std&#125;</span><br><span class="line">        base_config = super(CapsuleLayer, self).get_config()</span><br><span class="line">        <span class="keyword">return</span> dict(list(base_config.items()) + list(config.items()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squash</span><span class="params">(inputs)</span>:</span></span><br><span class="line">    vec_squared_norm = tf.reduce_sum(tf.square(inputs), axis=<span class="number">-1</span>, keep_dims=<span class="literal">True</span>)</span><br><span class="line">    scalar_factor = vec_squared_norm / (<span class="number">1</span> + vec_squared_norm) / tf.sqrt(vec_squared_norm + <span class="number">1e-8</span>)</span><br><span class="line">    vec_squashed = scalar_factor * inputs</span><br><span class="line">    <span class="keyword">return</span> vec_squashed</span><br></pre></td></tr></table></figure> 调用的时候 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">high_capsule = CapsuleLayer(input_units=<span class="number">8</span>,</span><br><span class="line">                            out_units=<span class="number">8</span>, max_len=<span class="number">50</span>,</span><br><span class="line">                            k_max=<span class="number">3</span>)((hist_seq, seq_len))</span><br><span class="line"><span class="comment">## hist_seq [None, 50, 8]</span></span><br><span class="line"><span class="comment">## seq_len [None, 50]</span></span><br></pre></td></tr></table></figure></p><h2 id="存在的问题">存在的问题</h2><p>有人通过实验指出，Capsule的Routing算法并不合理（包括一些改进的routing算法）:<a href="http://proceedings.mlr.press/v101/paik19a/paik19a.pdf" target="_blank" rel="noopener">Capsule Networks Need an Improved Routing Algorithm</a>。 文章中提到了一些Routing的方法，这里总结一下： 1. CapNet 《Dynamic routing between capsules》 <img src="16087948402135.jpg" /> 1. EMCaps 《Matrix capsules with em routing》 <img src="16087949130702.jpg" /> 1. OptimCaps 《An optimization view on dynamic routing between capsules》 <img src="16087949392584.jpg" /> 1. GroupCaps 《Group equivariant capsule networks》 <img src="16087949594454.jpg" /> 1. AttnCaps 《Dynamic capsule attention for visual question answering》 <img src="16087949936883.jpg" /></p><h2 id="参考文献">参考文献</h2><ol type="1"><li><p>https://medium.com/ai%C2%B3-theory-practice-business/understanding-hintons-capsule-networks-part-iii-dynamic-routing-between-capsules-349f6d30418</p></li><li><p>https://zhuanlan.zhihu.com/p/67910276</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FiBiNet：特征重要性+Bilinear交叉</title>
      <link href="/2020/07/07/FiBiNet/"/>
      <url>/2020/07/07/FiBiNet/</url>
      
        <content type="html"><![CDATA[<p>FiBiNET: Combining Feature Importance and Bilinear feature Interaction for Click-Through Rate Prediction</p><h2 id="简介">简介</h2><p>文章指出当前的许多通过特征组合进行CTR预估的工作主要使用特征向量的内积或哈达玛积来计算交叉特征，这种方法忽略了特征本身的重要程度。提出通过使用Squeeze-Excitation network (SENET) 结构动态学习特征的重要性以及使用一个双线性函数(Bilinear function)来更好的建模交叉特征。</p><h2 id="方法">方法</h2><p>本文的网络结构图如下： <img src="15941047971358.jpg" /></p><p>可以看到有2处与普通的CTR模型不同：1.SENET Layer 2.Bilinear-Interaction Layer。我们着重看这两部分。假设ID特征有<span class="math inline">\(f\)</span>个，第<span class="math inline">\(i\)</span>个特征的embedding为<span class="math inline">\(e_i \in R^k\)</span>，<span class="math inline">\(k\)</span>为embed_size，下面先看一次前向的数据流： 1.<span class="math inline">\(E=[e_1,e_2,...,e_f]\)</span>，<span class="math inline">\(A\)</span>=SENET(<span class="math inline">\(E\)</span>)，A为每个ID特征的权重，<span class="math inline">\(A\in R^f\)</span> 2.用权重<span class="math inline">\(A\)</span>给<span class="math inline">\(E\)</span>的对应特征加权，得到了加权后的Embedding <span class="math inline">\(V=[v_1,...,v_f],v_i\in R^k\)</span> 3.<span class="math inline">\(p\)</span>=Bilinear-Interaction(<span class="math inline">\(E\)</span>)，<span class="math inline">\(p=[p_1,...,p_n]\)</span>，其中<span class="math inline">\(n=\frac{f(f-2)}{2}\)</span>，即交叉组合数。同理<span class="math inline">\(q\)</span>=Bilinear-Interaction(<span class="math inline">\(V\)</span>) 4.将<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>concat起来之后过DNN输出结果。</p><h3 id="senet">SENET</h3><h4 id="squeeze">1.Squeeze</h4><p>将每一个ID特征压缩到一个标量，压缩可以是mean-pooling或者max-pooling，下面是mean-pooling的数学表示 <span class="math display">\[z_i = F_{sq}(e_i) = \frac{1}{k}\sum_{t=1}^ke_i^{(t)}\]</span> #### 2.Excitation 得到<span class="math inline">\(z\in R^{f\times 1}\)</span>后，类似AutoEncoder，过两层全连接得到每个特征的权重<span class="math inline">\(A=[a_1,...,a_f]\)</span> <span class="math display">\[A=F_{e x}(Z)=\sigma_{2}\left(W_{2} \sigma_{1}\left(W_{1} Z\right)\right)\]</span> 其中<span class="math inline">\(\sigma\)</span>为激活函数，<span class="math inline">\(W_1\in R^{f\times f/r}\)</span>，<span class="math inline">\(W_2\in R^{f/r \times f}\)</span>，<span class="math inline">\(r\)</span>为缩减比例，据说设置为8比较好。 这一步我理解是把不重要的特征的weight进一步压低。 #### 3.Re-weight 最后一步即是用<span class="math inline">\(A\)</span>缩放<span class="math inline">\(E\)</span>得到<span class="math inline">\(V\)</span> <span class="math display">\[V=F_{R e W e i g h t}(A, E)=\left[a_{1} \cdot e_{1}, \cdots, a_{f} \cdot e_{f}\right]=\left[v_{1}, \cdots, v_{f}\right]\]</span></p><h3 id="bilinear-interaction">Bilinear-Interaction</h3><p>一般的交叉方法用内积（<span class="math inline">\(\cdot\)</span>）或者哈达玛积（<span class="math inline">\(\odot\)</span>） <span class="math display">\[\begin{aligned}\left[a_{1}, a_{2}, \ldots, a_{n}\right] \cdot\left[b_{1}, b_{2}, \ldots, b_{n}\right] &amp;=\sum_{i=1}^{n} a_{i} b_{i} \\\left[a_{1}, a_{2}, \ldots, a_{n}\right] \odot\left[b_{1}, b_{2}, \ldots, b_{n}\right] &amp;=\left[a_{1} b_{1}, a_{2} b_{2}, \ldots, a_{n} b_{n}\right]\end{aligned}\]</span> 作者认为这些方法没有办法很好表示稀疏特征之间的组合，他选择在特征交叉时加入一个(<span class="math inline">\(k\times k\)</span>)的参数<span class="math inline">\(W\)</span> <span class="math display">\[p_{i,j} = v_i \cdot W \odot v_j\]</span> 这样要学习的<span class="math inline">\(W\)</span>会暴增，作者提出了三种方案： 1. Field-ALL：所有的交叉公用一个<span class="math inline">\(W\)</span> 2. Field-Each：每个在左边的<span class="math inline">\(v_i\)</span>都有一个<span class="math inline">\(W_i\)</span>，则一共需要<span class="math inline">\(f\)</span>个<span class="math inline">\(W\)</span> 3. Field-Interaction：每一对<span class="math inline">\((v_i,v_j)\)</span>单独一个<span class="math inline">\(W\)</span>，一共需要<span class="math inline">\(\frac{f(f-1)}{2}\)</span>个<span class="math inline">\(W\)</span></p><p>通过Bilinear-Interaction Layer，<span class="math inline">\(E \to p, V \to q\)</span>，最终<span class="math inline">\([p,q]\)</span>进DNN输出最后的logits。</p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
          <category> 论文阅读 </category>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AutoInt：构造高阶特征交叉</title>
      <link href="/2020/07/07/AutoInt/"/>
      <url>/2020/07/07/AutoInt/</url>
      
        <content type="html"><![CDATA[<p>AutoInt: Automatic Feature Interaction Learning via Self-Attentive Neural Networks (CIKM 2019)</p><h2 id="简介">简介</h2><p>本文通过另外的角度来做特征交叉和构造高阶特征，结构如下图 <img src="15941030467753.jpg" /></p><p>一句话总结：<strong>把Dense特征也转化为embedding，然后所有特征一起过Multi-Head Attention。</strong></p><p>对dense特征做embedding：每个dense特征对应一个嵌入向量，乘以具体的dense特征值 作为其最终的emeddding。</p><h2 id="优缺点">优缺点</h2><p>优点：简单易实现；可以让Dense和ID特征交叉。 缺点：提升似乎不是特别显著，如果模型里有了PNN，看起来再加AutoInt提升不大。</p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
          <category> 论文阅读 </category>
          
          <category> 推荐系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度召回算法</title>
      <link href="/2020/04/04/%E6%B7%B1%E5%BA%A6%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95/"/>
      <url>/2020/04/04/%E6%B7%B1%E5%BA%A6%E5%8F%AC%E5%9B%9E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="一简介">一、简介</h2><p>推荐系统的基本架构一般由索引、召回、粗排、精排、重排等几个部分构成，而其中的召回阶段（或者称之为Matching阶段）则主要负责根据用户和内容特征，从众多的内容库中找到用户可能感兴趣的内容。传统的召回算法，如ItemCF等，大多基于统计的方法来计算item之间的相似度，根据用户近期买过的商品进行召回。传统召回算法实现成本低，模型简单响应速度快，但是基于数据统计得到的相似关系缺乏个性化能力，召回商品的发现性，多样性较低。 近年来，随着深度学习的兴起，一些深度召回算法被提出。它们利用深度模型表达能力高，特征提取能力强的特点，提高了个性化召回算法的效果。最初的深度召回算法主要通过深度神经网络挖掘用户和商品在低维表示空间上的相似性，为用户召回低维表示相似的商品，这类方法我们往往称之为向量化召回算法。相比于基于数据统计的相似性计算，向量化召回的个性化程度更高，召回商品的发现性和多样性也较高。还有一些深度召回算法尝试建立商品之间的关系图，通过基于图的深度网络学习，从拓扑关系的角度捕捉商品之间的相关性，这类方法我们称之为基于图的深度召回算法。最后，还有一些方法致力于攻克深度模型带来的性能开销，使得深度模型能够在大规模的召回场景中可用，比如通过树结构和哈希的方法对召回的过程进行提速等等，这类方法我们称之为大规模深度召回算法。本文就从这三类方法展开，介绍一些现有的深度召回算法。</p><h2 id="二分类">二、分类</h2><ul><li><p>DeepMatch youtube在2016年提出了用深度模型进行多分类的监督训练，得到item和user的embedding最后在线上通过内积进行召回检索，算是深度模型时代向量化召回的开端。本文中将通过分类任务监督训练得到embedding最后通过内积进行检索的方法都归到这一类</p></li><li><p>Graph-based 这类方法大多同样是产出item和user的embedding，最后通过向量内积进行召回检索。但是这类方法引入图的结构来描述item和user之间的关系，他们声称相比于直接进行分类训练，引入了额外的拓扑信息。</p></li><li><p>Large-scale 这类方法可能属于上面两类方法，但是他们着重处理Large-scale的问题，致力于缩短召回检索的开销。</p></li></ul><h2 id="三deepmatch">三、DeepMatch</h2><h3 id="deep-neural-networks-for-youtube-recommendations.-recsys-2016">1. Deep neural networks for youtube recommendations. (RecSys 2016)</h3><p><strong>结构和特征</strong> 本文提出了一个较为基础的个性化向量召回算法，结构如下 <img src="15855389430461.jpg" /></p><p>主要特征： (a) 历史搜索query：把历史搜索的query分词后的token的embedding向量进行加权平均 (b) 人口统计学信息：性别、年龄、地域等 (c) 其他上下文信息 (d) Age信息：视频上传时间，保证时效性。</p><p><strong>训练和生效</strong> 离线训练时把问题建模成一个多分类问题，对用户U和上下文C，预测视频V是否点击，数学表示如下： <img src="15855396893807.jpg" /> 其中u和v为用户和商品的embedding，内积后进行softmax多分类。最后线上生效直接使用内积选取Top—N的视频。</p><h3 id="sequential-deep-matching-model-for-online-large-scale-recommender-system.-cikm-2019">2. Sequential Deep Matching Model for Online Large-scale Recommender System. (CIKM 2019)</h3><p>本文相比于上面Youtube的工作，引入了用户行为序列的信息进行序列化建模。示意图如下 <img src="15855399525004.jpg" /> 对于user，这边用user prediction network（上图虚线框）来提取用户向量，user prediction network中，使用Attention来提取用户长周期的特征(防止遗忘)，使用LSTM提取短周期的特征(注重实效)，最后通过一个门结构将长短周期和user embedding进行混合得到最终的用户向量表示。</p><h2 id="四graph-based">四、Graph-based</h2><h3 id="billion-scale-commodity-embedding-for-e-commerce-recommendation-in-alibaba.-kdd-2018">1. Billion-scale Commodity Embedding for E-commerce Recommendation in Alibaba. (KDD 2018)</h3><p>本文提出了一种基于图网络的低维表示提取方法，并且提出了两种改进方案。 提取的低维表示用于做个性化召回检索</p><h4 id="bge">BGE</h4><p>首先最基础的图网络提取低维表示的方法，BGE（Base Graph Embedding）如下： (1) 构建图：商品为点，用户行为为边，构建带权图，表示商品之间的关联。 (2) 采样：在图上进行Random walk的采样，得到一些商品序列，相关的商品在序列中同时出现的概率较高 (3) 训练：将采样得到的商品序列当做句子，其中每一个商品当做一个词、用NLP中的Skip-gram方法进行训练，得到每一个词的词向量，也就是每一个商品的向量。 <img src="15855442964204.jpg" /></p><h4 id="ges-eges">GES &amp; EGES</h4><p>上述的BGE方法难以处理冷启动的问题，新商品没有任何点击，无法产生有效的低维表示。 为了解决这个问题，本文提出了改进方案GES（Graph Embedding with Side information） 相比于只对商品学习低维表示，本方法还一并学习商品的其他属性信息。如下图SI0为item_id信息，SI1可能是store_id信息，etc. <img src="15855447612156.jpg" /> 最终一个商品的低维表示由所有的Side Information向量求均值得到： <img src="15855448211571.jpg" /></p><p>而EGES（Enhanced Graph Embedding with Side information）是GES的改进，认为不同的Information有着不同的重要性，最终商品的低维表示是各个Side Information的向量加权求和得到，权值也在训练中学习。 <img src="15855448929951.jpg" /></p><h3 id="graph-convolutional-neural-networks-for-web-scal-recommender-systems.-kdd-2018">2. Graph Convolutional Neural Networks for Web-Scal Recommender Systems. (KDD 2018)</h3><p>本文提出用图卷积网络来提取商品的低维表示。 图的构建方式还是同上，商品为点，用户行为作为边，构建一个图。但是本文用图卷积来生成一个商品的向量，即一个商品的向量通过他的近邻混合得到。下图展示了一个2层的图卷积，对于商品A，他的近邻是BCD，而BCD的近邻分别又是AC，ABEF，A。则商品A的最终向量由两层级的卷积操作得到。 <img src="15855475119931.jpg" /> 一次卷积操作的过程如下，实际上就是对所有近邻的向量过一层全连接，然后通过pooling得到<span class="math inline">\(n_u\)</span>，然后将目标向量<span class="math inline">\(z_u\)</span>和<span class="math inline">\(n_u\)</span> concat之后再过一个全连接，得到新的目标向量<span class="math inline">\(z_n^{new}\)</span> <img src="15855478737833.jpg" /></p><p>训练使用了max-margin ranking loss，数据组织为<span class="math inline">\(&lt;i,j,l&gt;\)</span>，其中<span class="math inline">\(&lt;i,j&gt;\)</span>为一个商品对，<span class="math inline">\(l\)</span>为label，表示这一对商品是否相关。</p><h2 id="五largescale">五、Large—Scale</h2><h3 id="candidate-generation-with-binary-codes-for-large-scale-top-n-recommendation.-cikm-2019">1. Candidate Generation with Binary Codes for Large-Scale Top-N Recommendation. (CIKM 2019)</h3><p>本文侧重关注召回检索的效率，结合哈希检索和向量化召回。通过对输出向量施加逐渐逼近符号函数的约束，使得生成的向量是二值的，以便使用哈希检索结构Multi-Index Hashing进行检索。这种检索方法的耗时与总商品数据量是一种次线性的关系。</p><p>本文其他部分与大多数DeepMatch类的算法相似，但是最后内积计算分类loss之前，对商品和用户向量施加一个符号函数<span class="math inline">\(sgn(x)\)</span>来让输出的向量成为二值的。但是，符号函数不可导，这里就用带参数的tanh函数来进行逼近，随着训练epoch逐渐增加参数<span class="math inline">\(\beta\)</span>大小，使其逼近符号函数<span class="math inline">\(sgn\)</span>。损失函数和训练过程如下图。 <img src="15855485459116.jpg" /> <img src="15855485133191.jpg" /></p><h3 id="learning-tree-based-deep-model-for-recommender-systems.-kdd-2018">2. Learning tree-based deep model for recommender systems. (KDD 2018)</h3><p>向量化召回由于使用向量内积作为最后的结果，表达能力有限，因此难以取得较好的个性化效果。如果使用深度模型，则超大的候选集合使得线上的延迟难以接受。本文结合了最大堆树和深度模型，提出了TDM算法。将庞大数量的商品分配到树的各个叶子节点，每个中间节点相当于其子节点商品的一个抽象表示，通过BeamSearch的方法对树结构进行高效检索。选取Top-K的商品，只需要深度模型做<span class="math inline">\(Klog(N)\)</span>次预测。 <img src="15855493488403.jpg" alt="w400" /></p><p>在训练过程中，每一个中间节点也被当做一个普通的item进行处理。 具体的训练方式是 树的结构 和 深度模型 交替进行更新。 当树的结构固定时，对于一条样本，如果用户点击了一个item，则这个item的搜索父节点也被视作点击。如此便可构造数据集对深度模型进行训练。 而树的结构，则是通过对当前的embedding进行聚类得到。 <img src="15855518986729.jpg" /></p><h3 id="joint-optimization-of-tree-based-index-and-deep-model-for-recommender-systems.-nips-2019">3. Joint Optimization of Tree-based Index and Deep Model for Recommender Systems. (NIPS 2019)</h3><p>本文是对上面TDM算法的改进。上面TDM算法中，树的构建和深度模型的训练是分隔开的，目标并不相同，可能两者的优化相互牵制导致总体效果次优。 本文主要有两个改进： 1.树结构、深度模型联合优化 通过最大似然构建联合优化的loss function。其中树结构的优化难以求解，转化为带权二部图的最大匹配问题，通过贪心算法求解。 2.用户序列特征分层建模 深度模型中用到了用户的行为序列，TDM中训练数的中间层时在序列特征方面也是用的item_id粒度的序列特征。在本文中改进为使用当前层的embedding作为序列的特征。这样可以减少每层训练的噪声，并且可以从粗到细的精准建模。</p><h2 id="六总结">六、总结</h2><h4 id="deep-neural-networks-for-youtube-recommendations">1. Deep neural networks for youtube recommendations</h4><p>方法名：无 动机：使用深度模型进行个性化的召回，同时保证效率 方法：通过深度模型多分类任务训练，得到用户和商品的向量，用向量内积做召回检索。</p><h4 id="sequential-deep-matching-model-for-online-large-scale-recommender-system">2. Sequential Deep Matching Model for Online Large-scale Recommender System</h4><p>方法名：SDM 动机：建模用户行为序列 方法：引入用户长短期行为序列，分别用Attention和LSTM结构进行建模，最终进行向量召回。</p><h4 id="billion-scale-commodity-embedding-for-e-commerce-recommendation-in-alibaba.">3. Billion-scale Commodity Embedding for E-commerce Recommendation in Alibaba.</h4><p>方法名：BGE，GES，EGES 动机：使用图网络表示商品之间的关系，再学习商品的低维表示 方法：使用用户行为建图，通过采样得到多条商品轨迹。将轨迹当成句子，商品当做词，通过NLP中求解词向量的方法求解商品向量。并且使用商品其他属性的向量来缓解冷启动问题。</p><h4 id="graph-convolutional-neural-networks-for-web-scal-recommender-systems.">4. Graph Convolutional Neural Networks for Web-Scal Recommender Systems.</h4><p>方法名：PinSage 动机：使用图表示商品之间的关系，再使用图卷积网络学习商品的低维表示 方法：每一个商品的embedding由其近邻的embedding通过图卷积操作得到。通过max-margine ranking loss进行训练。</p><h4 id="candidate-generation-with-binary-codes-for-large-scale-top-n-recommendation.">5. Candidate Generation with Binary Codes for Large-Scale Top-N Recommendation.</h4><p>方法名：CICAR 动机：通过高效哈希检索结构来提升召回的效率 方法：使用次线性复杂度的哈希检索方法Multi-index hashing，需要embedding是二值的。因此在现有双塔内积网络的基础上，使用一个近似符号函数的映射函数<span class="math inline">\(tanh_\beta\)</span>将输出的向量映射到二值。</p><h4 id="learning-tree-based-deep-model-for-recommender-systems.">6. Learning tree-based deep model for recommender systems.</h4><p>方法名：TDM 动机：通过内积进行召回表达能力有限，使用深度模型打分则商品太多开销过大。 方法：在全部N个商品集合上构建树的结构，在树上通过BeamSearch进行检索TopK商品，深度模型只需要预测<span class="math inline">\(Klog(N)\)</span>次。树的中间节点是商品的抽象，当做商品一次训练，其label来自于子节点。深度模型和树结构交替训练。</p><h4 id="joint-optimization-of-tree-based-index-and-deep-model-for-recommender-systems.">7. Joint Optimization of Tree-based Index and Deep Model for Recommender Systems.</h4><p>方法名：JTM 动机：TDM中深度模型和树结构训练是完全分隔开的，目标不同可能导致相互牵制无法训练到最优。 方法：构建统一loss function，深度模型和树结构联合优化。树结构的优化是个较难的组合优化问题，转化为带权二部图匹配问题后用贪心算法求解。</p><h2 id="七结语">七、结语</h2><p>本文介绍了近几年内的一些深度召回算法，主要把它们划分成“Deep Matching类算法”、“基于图的算法”、“面向大规模场景算法”3类算法，并对这3类算法进行归纳和总结，分析他们的动机、做法和优缺点。深度学习在推荐系统中的应用是近年来持续的热门研究课题，每年都会有大量新技术和新模型出现。我们希望这篇文章能帮助读者对这个领域有一个大致的了解，并为未来的研究提供一些思路和参考。</p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas处理MovieLen25M数据集</title>
      <link href="/2020/03/21/Pandas%E5%A4%84%E7%90%86MovieLen25M%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
      <url>/2020/03/21/Pandas%E5%A4%84%E7%90%86MovieLen25M%E6%95%B0%E6%8D%AE%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>最近做了一些推荐侧召回的实验尝试，除了在业务的数据上进行测试，我还想在公开数据集上进行验证。参考Related works，最终选择使用MovieLen和Amazon的数据集。由于这两个数据集给的是裸的数据，因此需要我们根据自己的需要做一些处理。这里我用pandas来做数据的分析和处理。 Pandas是数据科学常用的工具，但是说来惭愧，我之前倒是很少用Pandas。因为之前做强化学习较多，不太需要大量的这种数据分析。因此这次也就趁机在熟悉一下。我个人觉得相比于算法原理，工具类的东西大致记录一下就好。工作中用到多了自然就记住了，记不住的说明平时也不怎么用，到时候再查就好，相关的文档网上有很多很多，倒是不必死记。</p><p>废话不多说，直接上Notebook吧，该说的都在注释里。（下面的链接是个html，但是如果我以HTML的格式放到资源文件夹里，编译后blog首页排版会有错） <a href="/2020/03/21/Pandas%E5%A4%84%E7%90%86MovieLen25M%E6%95%B0%E6%8D%AE%E9%9B%86/ml_data_process" title="[pandas数据处理notebook]">[pandas数据处理notebook]</a></p><p>经过这样处理，我得到了几个处理后的表，表的含义见notebook <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">viewed_sequence</span><br><span class="line">genome_feature</span><br><span class="line">genres_tag_one_hot_feature</span><br><span class="line">movie_rating_feature</span><br><span class="line">tag_feature_movie</span><br><span class="line">tag_feature_user</span><br><span class="line">user_rating_feature</span><br></pre></td></tr></table></figure></p><p>最后通过python+MPI并行的聚合生成最后的数据，写入到本地文件 <a href="/2020/03/21/Pandas%E5%A4%84%E7%90%86MovieLen25M%E6%95%B0%E6%8D%AE%E9%9B%86/run.py" title="[python+MPI产出聚合数据集]">[python+MPI产出聚合数据集]</a></p><p>不过最终处理出来的数据集有十几个G，受限于线上docker容器的内存限制，无法放到一个文件里序列化存储和恢复，还是得通过file的方式来读，算是没有完美的达到预期，但是问题不大。</p>]]></content>
      
      
      <categories>
          
          <category> ML </category>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020年03月15日</title>
      <link href="/2020/03/16/2020-03-15/"/>
      <url>/2020/03/16/2020-03-15/</url>
      
        <content type="html"><![CDATA[<p>今天感觉最近的生活状态不是很对，花了很多时间在没有特别多意义的事情上。如何能够专注在一个事情上，做更深入的思考，这时一个值得探索的课题。不仅是做完，更是打磨完善，直到超出某个阈值，这样才能把事情做到让旁人觉得值得点赞的程度。</p><p>此外，“以为自己想明白了”和“自己确实想明白了”之前是有个gap的。能把自己想明白的东西整理输出出来，这才是真正的想明白了。很多时候以为自己想明白了，但是一跟别人说，或者一做ppt就讲不明白，说明理解的还不够通透。因此，多思考，并且把自己的思考输出、记录下来，这应该是有利于理解和积累的。这也是我为什么又重新开始写自己的blog。 看着师弟，同级还有师兄中，都有人在知乎上撰写技术文章，我现在也感觉到这里面确实是有必要的，不管是对内的自我沉淀，和对外的自我宣传。</p><p>此外，还有很多事情，也是工作之后看到身边优秀的人们才渐渐想明白。包括对自我行为的认知，包括怎么做事情会高效，怎么样才能快速拿结果避免无用功。这些事情现在已经渐渐有了一些自己的理解，以后有机会在慢慢详述。当然还有一些事情我隐约觉得很重要，但是目前还没有一个清晰的认知和思考，在之后的生活中应该会渐渐参悟吧。</p><p>最后，做什么事情都需要坚持，希望写blog这个事情我也能坚持下来，深入思考，不断打磨，不断积累。相信长期下来应该有不错的收货。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/01/20/hello-world/"/>
      <url>/2020/01/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><hr /><p>test math <span class="math inline">\(e=mc^2\)</span> <span class="math inline">\(x = argmax(\sum_{i=0}^N \mu(a_i|x))\)</span></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加Tag和categories的例子</title>
      <link href="/2020/01/20/post-title-with-whitespace/"/>
      <url>/2020/01/20/post-title-with-whitespace/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 临时 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
